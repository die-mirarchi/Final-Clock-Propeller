
main.elf:     file format elf32-littlearm
main.elf
architecture: armv7, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000009

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000220 memsz 0x00000220 flags r-x
private flags = 0x5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000220  08000000  08000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  00001220  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  20000000  20000000  00000000  2**0
                  ALLOC
  3 .debug_info   00000bc6  00000000  00000000  00001220  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000216  00000000  00000000  00001de6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_loclists 00000083  00000000  00000000  00001ffc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000020  00000000  00000000  0000207f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_rnglists 0000002f  00000000  00000000  0000209f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000362  00000000  00000000  000020ce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    00000438  00000000  00000000  00002430  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000046  00000000  00000000  00002868  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002d  00000000  00000000  000028ae  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000030  00000000  00000000  000028dc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
08000000 l    d  .text	00000000 .text
20000000 l    d  .data	00000000 .data
20000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 main.c
08000000 g     O .text	00000008 vector_table
08000008 g     F .text	000001fc main



Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 50 00 20 09 00 00 08                             .P. ....

08000008 <main>:
	(interrupt_t) main,										// 0x0000_0004 Reset
};


int main(void)
{
 8000008:	b5f0      	push	{r4, r5, r6, r7, lr}
	// ========================================
	// Configuración de reloj: 72MHz vía PLL
	// ========================================
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 800000a:	4b77      	ldr	r3, [pc, #476]	@ (80001e8 <main+0x1e0>)
{
 800000c:	b089      	sub	sp, #36	@ 0x24
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 800000e:	681a      	ldr	r2, [r3, #0]
 8000010:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8000014:	601a      	str	r2, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 17)));    // Esperar HSE ready
 8000016:	681a      	ldr	r2, [r3, #0]
 8000018:	0392      	lsls	r2, r2, #14
 800001a:	d5fc      	bpl.n	8000016 <main+0xe>
	
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 800001c:	6819      	ldr	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 800001e:	4a72      	ldr	r2, [pc, #456]	@ (80001e8 <main+0x1e0>)
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 8000020:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 8000024:	6019      	str	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
 8000026:	6859      	ldr	r1, [r3, #4]
 8000028:	f441 11e0 	orr.w	r1, r1, #1835008	@ 0x1c0000
 800002c:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
 800002e:	6859      	ldr	r1, [r3, #4]
 8000030:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 8000034:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
 8000036:	6819      	ldr	r1, [r3, #0]
 8000038:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 800003c:	6019      	str	r1, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 800003e:	6813      	ldr	r3, [r2, #0]
 8000040:	019f      	lsls	r7, r3, #6
 8000042:	d5fc      	bpl.n	800003e <main+0x36>
	
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000044:	4869      	ldr	r0, [pc, #420]	@ (80001ec <main+0x1e4>)
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
	
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 8000046:	4b68      	ldr	r3, [pc, #416]	@ (80001e8 <main+0x1e0>)
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000048:	6801      	ldr	r1, [r0, #0]
 800004a:	f041 0102 	orr.w	r1, r1, #2
 800004e:	6001      	str	r1, [r0, #0]
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
 8000050:	6851      	ldr	r1, [r2, #4]
 8000052:	f441 6180 	orr.w	r1, r1, #1024	@ 0x400
 8000056:	6051      	str	r1, [r2, #4]
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
 8000058:	6851      	ldr	r1, [r2, #4]
 800005a:	f041 0102 	orr.w	r1, r1, #2
 800005e:	6051      	str	r1, [r2, #4]
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 8000060:	685a      	ldr	r2, [r3, #4]
 8000062:	0716      	lsls	r6, r2, #28
 8000064:	d5fc      	bpl.n	8000060 <main+0x58>
	
        // ========================================
        // Habilitar relojes periféricos
        // ========================================
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 8000066:	699a      	ldr	r2, [r3, #24]
	// ========================================
	// AFIO->MAPR: SWJ_CFG = 010 (JTAG-DP Disabled, SW-DP Enabled)
	// Esto libera PA15, PB3, PB4 pero mantiene PA13 (SWDIO) y PA14 (SWCLK)
	uint32_t *AFIO_MAPR = (uint32_t*)(0x40010000 + 0x04);  // AFIO base + offset MAPR
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 8000068:	4961      	ldr	r1, [pc, #388]	@ (80001f0 <main+0x1e8>)
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 800006a:	f042 0204 	orr.w	r2, r2, #4
 800006e:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 3);  // GPIOB clock enable
 8000070:	699a      	ldr	r2, [r3, #24]

        // Configurar ADC primero, ANTES de encender
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * 9));
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (0b111 << (3 * 9)); // Sample time = 239.5 ciclos
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
        DEVMAP->ADC[ADC1].REGs.SQR3  = 9;                    // Canal 9 (PB1) como primera conversión
 8000072:	2009      	movs	r0, #9
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 3);  // GPIOB clock enable
 8000074:	f042 0208 	orr.w	r2, r2, #8
 8000078:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 9);  // ADC1 clock enable
 800007a:	699c      	ldr	r4, [r3, #24]
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 800007c:	684a      	ldr	r2, [r1, #4]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 9);  // ADC1 clock enable
 800007e:	f444 7400 	orr.w	r4, r4, #512	@ 0x200
 8000082:	619c      	str	r4, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 0);  // AFIO clock enable
 8000084:	699c      	ldr	r4, [r3, #24]
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 8000086:	f022 62e0 	bic.w	r2, r2, #117440512	@ 0x7000000
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 0);  // AFIO clock enable
 800008a:	f044 0401 	orr.w	r4, r4, #1
 800008e:	619c      	str	r4, [r3, #24]
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 8000090:	f8d1 4c00 	ldr.w	r4, [r1, #3072]	@ 0xc00
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 8000094:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 8000098:	f024 04f0 	bic.w	r4, r4, #240	@ 0xf0
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 800009c:	604a      	str	r2, [r1, #4]
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 800009e:	f8c1 4c00 	str.w	r4, [r1, #3072]	@ 0xc00
        DEVMAP->RCC.REGs.CFGR &= ~(0b11 << 14);
 80000a2:	6859      	ldr	r1, [r3, #4]
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * 9));
 80000a4:	4a53      	ldr	r2, [pc, #332]	@ (80001f4 <main+0x1ec>)
        DEVMAP->RCC.REGs.CFGR &= ~(0b11 << 14);
 80000a6:	f421 4140 	bic.w	r1, r1, #49152	@ 0xc000
 80000aa:	6059      	str	r1, [r3, #4]
        DEVMAP->RCC.REGs.CFGR |=  (0b10 << 14);             // ADCPRE = 10: PCLK2/6
 80000ac:	6859      	ldr	r1, [r3, #4]
 80000ae:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 80000b2:	6059      	str	r1, [r3, #4]
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
        
        // Ahora encender y calibrar
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Encender ADC (primera vez)
        for(volatile int i=0; i<1000; i++);                  // Delay para estabilización
 80000b4:	2100      	movs	r1, #0
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * 9));
 80000b6:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80000ba:	f023 5360 	bic.w	r3, r3, #939524096	@ 0x38000000
 80000be:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (0b111 << (3 * 9)); // Sample time = 239.5 ciclos
 80000c2:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80000c6:	f043 5360 	orr.w	r3, r3, #939524096	@ 0x38000000
 80000ca:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
 80000ce:	f8d2 342c 	ldr.w	r3, [r2, #1068]	@ 0x42c
 80000d2:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 80000d6:	f8c2 342c 	str.w	r3, [r2, #1068]	@ 0x42c
        DEVMAP->ADC[ADC1].REGs.SQR3  = 9;                    // Canal 9 (PB1) como primera conversión
 80000da:	f8c2 0434 	str.w	r0, [r2, #1076]	@ 0x434
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80000de:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 80000e2:	f043 0302 	orr.w	r3, r3, #2
 80000e6:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Encender ADC (primera vez)
 80000ea:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 80000ee:	f043 0301 	orr.w	r3, r3, #1
 80000f2:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        for(volatile int i=0; i<1000; i++);                  // Delay para estabilización
 80000f6:	9100      	str	r1, [sp, #0]
 80000f8:	9b00      	ldr	r3, [sp, #0]
 80000fa:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80000fe:	da06      	bge.n	800010e <main+0x106>
 8000100:	9b00      	ldr	r3, [sp, #0]
 8000102:	3301      	adds	r3, #1
 8000104:	9300      	str	r3, [sp, #0]
 8000106:	9b00      	ldr	r3, [sp, #0]
 8000108:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800010c:	dbf8      	blt.n	8000100 <main+0xf8>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 3);             // RSTCAL: Reset calibration
 800010e:	4a39      	ldr	r2, [pc, #228]	@ (80001f4 <main+0x1ec>)
 8000110:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000114:	f043 0308 	orr.w	r3, r3, #8
 8000118:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 3));       // Esperar que se complete reset
 800011c:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000120:	071d      	lsls	r5, r3, #28
 8000122:	d4fb      	bmi.n	800011c <main+0x114>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 8000124:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000128:	4932      	ldr	r1, [pc, #200]	@ (80001f4 <main+0x1ec>)
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 800012a:	f043 0304 	orr.w	r3, r3, #4
 800012e:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000132:	f8d1 3408 	ldr.w	r3, [r1, #1032]	@ 0x408
 8000136:	075c      	lsls	r4, r3, #29
 8000138:	d4fb      	bmi.n	8000132 <main+0x12a>
        // ========================================
        // Configurar PA[15:0] como salidas 50MHz push-pull
        // ========================================
	// CRL configura PA[7:0]:   MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
	// CRH configura PA[15:8]:  MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
	DEVMAP->GPIOs[GPIOA].REGs.CRL = 0x33333333;  // PA[7:0]  como salidas
 800013a:	f04f 3033 	mov.w	r0, #858993459	@ 0x33333333
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Iniciar conversión continua
 800013e:	f8d1 3408 	ldr.w	r3, [r1, #1032]	@ 0x408
	DEVMAP->GPIOs[GPIOA].REGs.CRL = 0x33333333;  // PA[7:0]  como salidas
 8000142:	4a2b      	ldr	r2, [pc, #172]	@ (80001f0 <main+0x1e8>)
	
	// ========================================
	// Bucle principal: encender LEDs en secuencia
	// ========================================
	// LEDs en PA0-PA12 y PA15 (14 LEDs totales)
        const uint16_t led_pins[14] = {
 8000144:	4e2c      	ldr	r6, [pc, #176]	@ (80001f8 <main+0x1f0>)
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Iniciar conversión continua
 8000146:	f043 0301 	orr.w	r3, r3, #1
        const uint16_t led_pins[14] = {
 800014a:	ad01      	add	r5, sp, #4
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Iniciar conversión continua
 800014c:	f8c1 3408 	str.w	r3, [r1, #1032]	@ 0x408
	DEVMAP->GPIOs[GPIOA].REGs.CRL = 0x33333333;  // PA[7:0]  como salidas
 8000150:	f8c2 0800 	str.w	r0, [r2, #2048]	@ 0x800
	DEVMAP->GPIOs[GPIOA].REGs.CRH = 0x33333333;  // PA[15:8] como salidas
 8000154:	f8c2 0804 	str.w	r0, [r2, #2052]	@ 0x804
        const uint16_t led_pins[14] = {
 8000158:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800015a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800015c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8000160:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        const uint32_t falling_threshold_mv = 1300;
        const uint32_t rising_threshold_mv = 1600;

        // Preparar estado inicial del comparador de umbral
        // Descartar la primera muestra tras el arranque para evitar lecturas iniciales incorrectas
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000164:	4c23      	ldr	r4, [pc, #140]	@ (80001f4 <main+0x1ec>)
 8000166:	f8d4 3400 	ldr.w	r3, [r4, #1024]	@ 0x400
 800016a:	0798      	lsls	r0, r3, #30
 800016c:	d5fb      	bpl.n	8000166 <main+0x15e>
        (void)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 800016e:	f8d4 344c 	ldr.w	r3, [r4, #1100]	@ 0x44c

        // Preparar estado inicial del comparador de umbral con la siguiente conversión válida
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000172:	4a20      	ldr	r2, [pc, #128]	@ (80001f4 <main+0x1ec>)
 8000174:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 8000178:	0799      	lsls	r1, r3, #30
 800017a:	d5fb      	bpl.n	8000174 <main+0x16c>
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
        uint32_t initial_voltage_mv = (initial_sample * 3300U) / 4095U;
 800017c:	f640 4ce4 	movw	ip, #3300	@ 0xce4
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 8000180:	f8d2 144c 	ldr.w	r1, [r2, #1100]	@ 0x44c
        uint8_t low_detected = (initial_voltage_mv < falling_threshold_mv);
 8000184:	f8df e074 	ldr.w	lr, [pc, #116]	@ 80001fc <main+0x1f4>
        uint32_t initial_voltage_mv = (initial_sample * 3300U) / 4095U;
 8000188:	b289      	uxth	r1, r1
 800018a:	fb0c f101 	mul.w	r1, ip, r1

        // Mostrar primer LED encendido
        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 800018e:	2380      	movs	r3, #128	@ 0x80
        uint8_t low_detected = (initial_voltage_mv < falling_threshold_mv);
 8000190:	4571      	cmp	r1, lr
        uint8_t led_index = 0;
 8000192:	f04f 0000 	mov.w	r0, #0
        uint8_t low_detected = (initial_voltage_mv < falling_threshold_mv);
 8000196:	bf8c      	ite	hi
 8000198:	2100      	movhi	r1, #0
 800019a:	2101      	movls	r1, #1
                        led_index++;
                        if (led_index >= 14) {
                                led_index = 0;
                        }

                        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 800019c:	2601      	movs	r6, #1
        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 800019e:	4d14      	ldr	r5, [pc, #80]	@ (80001f0 <main+0x1e8>)
                while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 80001a0:	4a14      	ldr	r2, [pc, #80]	@ (80001f4 <main+0x1ec>)
                if (low_detected && (voltage_mv >= rising_threshold_mv)) {
 80001a2:	4c17      	ldr	r4, [pc, #92]	@ (8000200 <main+0x1f8>)
        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 80001a4:	f8c5 380c 	str.w	r3, [r5, #2060]	@ 0x80c
                while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 80001a8:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 80001ac:	079b      	lsls	r3, r3, #30
 80001ae:	d5fb      	bpl.n	80001a8 <main+0x1a0>
                uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 80001b0:	f8d2 344c 	ldr.w	r3, [r2, #1100]	@ 0x44c
                uint32_t voltage_mv = (sample * 3300U) / 4095U;
 80001b4:	b29b      	uxth	r3, r3
 80001b6:	fb0c f303 	mul.w	r3, ip, r3
                if (!low_detected && (voltage_mv < falling_threshold_mv)) {
 80001ba:	b921      	cbnz	r1, 80001c6 <main+0x1be>
 80001bc:	4573      	cmp	r3, lr
 80001be:	bf8c      	ite	hi
 80001c0:	2100      	movhi	r1, #0
 80001c2:	2101      	movls	r1, #1
 80001c4:	e7f0      	b.n	80001a8 <main+0x1a0>
                if (low_detected && (voltage_mv >= rising_threshold_mv)) {
 80001c6:	42a3      	cmp	r3, r4
                        led_index++;
 80001c8:	f100 0701 	add.w	r7, r0, #1
                if (low_detected && (voltage_mv >= rising_threshold_mv)) {
 80001cc:	d3ec      	bcc.n	80001a8 <main+0x1a0>
                        led_index++;
 80001ce:	b2f8      	uxtb	r0, r7
                        if (led_index >= 14) {
 80001d0:	280d      	cmp	r0, #13
 80001d2:	bf88      	it	hi
 80001d4:	2000      	movhi	r0, #0
                        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 80001d6:	eb0d 0340 	add.w	r3, sp, r0, lsl #1
 80001da:	889b      	ldrh	r3, [r3, #4]
                        low_detected = 0;
 80001dc:	2100      	movs	r1, #0
                        DEVMAP->GPIOs[GPIOA].REGs.ODR = (1 << led_pins[led_index]);
 80001de:	fa06 f303 	lsl.w	r3, r6, r3
 80001e2:	f8c5 380c 	str.w	r3, [r5, #2060]	@ 0x80c
                        low_detected = 0;
 80001e6:	e7df      	b.n	80001a8 <main+0x1a0>
 80001e8:	40021000 	.word	0x40021000
 80001ec:	40022000 	.word	0x40022000
 80001f0:	40010000 	.word	0x40010000
 80001f4:	40012000 	.word	0x40012000
 80001f8:	08000204 	.word	0x08000204
 80001fc:	00513aeb 	.word	0x00513aeb
 8000200:	0063f9c0 	.word	0x0063f9c0
 8000204:	00060007 	.word	0x00060007
 8000208:	00040005 	.word	0x00040005
 800020c:	00020003 	.word	0x00020003
 8000210:	00000001 	.word	0x00000001
 8000214:	00090008 	.word	0x00090008
 8000218:	000b000a 	.word	0x000b000a
 800021c:	000f000c 	.word	0x000f000c

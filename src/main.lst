
main.elf:     file format elf32-littlearm
main.elf
architecture: armv7, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080000e1

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x000005a4 memsz 0x000005a4 flags r-x
    LOAD off    0x00002000 vaddr 0x20000000 paddr 0x080005a4 align 2**12
         filesz 0x0000001c memsz 0x00000028 flags rw-
private flags = 0x5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005a4  08000000  08000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  20000000  080005a4  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000c  2000001c  080005c0  0000201c  2**2
                  ALLOC
  3 .debug_info   00000cb6  00000000  00000000  0000201c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000248  00000000  00000000  00002cd2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_loclists 00000085  00000000  00000000  00002f1a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000028  00000000  00000000  00002f9f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_rnglists 0000001b  00000000  00000000  00002fc7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   000004aa  00000000  00000000  00002fe2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    000004d4  00000000  00000000  0000348c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000046  00000000  00000000  00003960  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002d  00000000  00000000  000039a6  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000058  00000000  00000000  000039d4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
08000000 l    d  .text	00000000 .text
20000000 l    d  .data	00000000 .data
2000001c l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 main.c
20000024 l     O .bss	00000001 low_detected
20000020 l     O .bss	00000004 last_capture_ticks
20000018 l     O .data	00000004 delta_ticks
2000001e l     O .bss	00000002 laps
0800043c l     O .text	00000168 led_pattern
2000001c l     O .bss	00000001 delta_buffer_index
20000004 l     O .data	00000014 delta_buffer
20000000 l     O .data	00000004 delta_sum
0800033c g     F .text	00000100 ADC1_2_IRQHandler
08000000 g     O .text	000000e0 vector_table
080000e0 g     F .text	0000025c main



Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 50 00 20 e1 00 00 08 00 00 00 00 00 00 00 00     .P. ............
	...
 8000088:	3d 03 00 08 00 00 00 00 00 00 00 00 00 00 00 00     =...............
	...

080000e0 <main>:
	0,														// 0x0000_00DC
};


int main(void)
{
 80000e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// ========================================
	// Configuración de reloj: 72MHz vía PLL
	// ========================================
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 80000e4:	4b8b      	ldr	r3, [pc, #556]	@ (8000314 <main+0x234>)
{
 80000e6:	b082      	sub	sp, #8
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 80000e8:	681a      	ldr	r2, [r3, #0]
 80000ea:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 80000ee:	601a      	str	r2, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 17)));    // Esperar HSE ready
 80000f0:	681a      	ldr	r2, [r3, #0]
 80000f2:	0397      	lsls	r7, r2, #14
 80000f4:	d5fc      	bpl.n	80000f0 <main+0x10>
	
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 80000f6:	6819      	ldr	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 80000f8:	4a86      	ldr	r2, [pc, #536]	@ (8000314 <main+0x234>)
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 80000fa:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 80000fe:	6019      	str	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
 8000100:	6859      	ldr	r1, [r3, #4]
 8000102:	f441 11e0 	orr.w	r1, r1, #1835008	@ 0x1c0000
 8000106:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
 8000108:	6859      	ldr	r1, [r3, #4]
 800010a:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 800010e:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
 8000110:	6819      	ldr	r1, [r3, #0]
 8000112:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 8000116:	6019      	str	r1, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 8000118:	6813      	ldr	r3, [r2, #0]
 800011a:	019e      	lsls	r6, r3, #6
 800011c:	d5fc      	bpl.n	8000118 <main+0x38>
	
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
	
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 800011e:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000122:	4c7d      	ldr	r4, [pc, #500]	@ (8000318 <main+0x238>)
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 8000124:	4b7b      	ldr	r3, [pc, #492]	@ (8000314 <main+0x234>)
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000126:	6820      	ldr	r0, [r4, #0]
 8000128:	f040 0002 	orr.w	r0, r0, #2
 800012c:	6020      	str	r0, [r4, #0]
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
 800012e:	6850      	ldr	r0, [r2, #4]
 8000130:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
 8000134:	6050      	str	r0, [r2, #4]
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
 8000136:	6850      	ldr	r0, [r2, #4]
 8000138:	f040 0002 	orr.w	r0, r0, #2
 800013c:	6050      	str	r0, [r2, #4]
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 800013e:	685a      	ldr	r2, [r3, #4]
 8000140:	0715      	lsls	r5, r2, #28
 8000142:	d5fc      	bpl.n	800013e <main+0x5e>
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);

        // ========================================
        // Configurar TIM2 como contador libre para time-stamping
        // ========================================
        DEVMAP->TIMs[TIM2].REGs.CR1 = 0;
 8000144:	2400      	movs	r4, #0
        DEVMAP->TIMs[TIM2].REGs.PSC = TIM2_PRESCALER_30KHZ;            // 72MHz / 2400 = 30kHz -> 33.33us por tick
 8000146:	f640 1c5f 	movw	ip, #2399	@ 0x95f
        DEVMAP->TIMs[TIM2].REGs.ARR = TIM2_AUTO_RELOAD_MAX_16BIT;      // Conteo libre de 16 bits
 800014a:	f64f 77ff 	movw	r7, #65535	@ 0xffff
        DEVMAP->RCC.REGs.APB1ENR |= (1 << 0);  // TIM2 clock enable
 800014e:	69da      	ldr	r2, [r3, #28]

        // Configurar ADC primero, ANTES de encender
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (ADC_SAMPLE_TIME_CYCLES << (3 * ADC_CHANNEL_B1)); // Sample time = 239.5 ciclos
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
        DEVMAP->ADC[ADC1].REGs.SQR3  = ADC_CHANNEL_B1;       // Canal 9 (PB1) como primera conversión
 8000150:	2509      	movs	r5, #9
        DEVMAP->RCC.REGs.APB1ENR |= (1 << 0);  // TIM2 clock enable
 8000152:	f042 0201 	orr.w	r2, r2, #1
 8000156:	61da      	str	r2, [r3, #28]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 8000158:	699a      	ldr	r2, [r3, #24]
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 800015a:	4870      	ldr	r0, [pc, #448]	@ (800031c <main+0x23c>)
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 800015c:	f042 0204 	orr.w	r2, r2, #4
 8000160:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 3);  // GPIOB clock enable
 8000162:	699a      	ldr	r2, [r3, #24]
 8000164:	f042 0208 	orr.w	r2, r2, #8
 8000168:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 9);  // ADC1 clock enable
 800016a:	699a      	ldr	r2, [r3, #24]
 800016c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8000170:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 0);  // AFIO clock enable
 8000172:	699a      	ldr	r2, [r3, #24]
 8000174:	f042 0201 	orr.w	r2, r2, #1
 8000178:	619a      	str	r2, [r3, #24]
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 800017a:	f8d0 6c00 	ldr.w	r6, [r0, #3072]	@ 0xc00
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
 800017e:	4a68      	ldr	r2, [pc, #416]	@ (8000320 <main+0x240>)
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 8000180:	f026 06f0 	bic.w	r6, r6, #240	@ 0xf0
 8000184:	f8c0 6c00 	str.w	r6, [r0, #3072]	@ 0xc00
        DEVMAP->TIMs[TIM2].REGs.CR1 = 0;
 8000188:	600c      	str	r4, [r1, #0]
        DEVMAP->TIMs[TIM2].REGs.PSC = TIM2_PRESCALER_30KHZ;            // 72MHz / 2400 = 30kHz -> 33.33us por tick
 800018a:	f8c1 c028 	str.w	ip, [r1, #40]	@ 0x28
        DEVMAP->TIMs[TIM2].REGs.ARR = TIM2_AUTO_RELOAD_MAX_16BIT;      // Conteo libre de 16 bits
 800018e:	62cf      	str	r7, [r1, #44]	@ 0x2c
        DEVMAP->TIMs[TIM2].REGs.CNT = 0;
 8000190:	624c      	str	r4, [r1, #36]	@ 0x24
        DEVMAP->TIMs[TIM2].REGs.CR1 |= (1 << 0);             // CEN: habilitar contador
 8000192:	680e      	ldr	r6, [r1, #0]
 8000194:	f046 0601 	orr.w	r6, r6, #1
 8000198:	600e      	str	r6, [r1, #0]
        DEVMAP->RCC.REGs.CFGR &= ~(0b11 << 14);
 800019a:	6859      	ldr	r1, [r3, #4]
 800019c:	f421 4140 	bic.w	r1, r1, #49152	@ 0xc000
 80001a0:	6059      	str	r1, [r3, #4]
        DEVMAP->RCC.REGs.CFGR |=  (0b11 << 14);             // ADCPRE = 10: PCLK2/6
 80001a2:	6859      	ldr	r1, [r3, #4]
 80001a4:	f441 4140 	orr.w	r1, r1, #49152	@ 0xc000
 80001a8:	6059      	str	r1, [r3, #4]
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
 80001aa:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80001ae:	f023 5360 	bic.w	r3, r3, #939524096	@ 0x38000000
 80001b2:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (ADC_SAMPLE_TIME_CYCLES << (3 * ADC_CHANNEL_B1)); // Sample time = 239.5 ciclos
 80001b6:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80001ba:	f043 5360 	orr.w	r3, r3, #939524096	@ 0x38000000
 80001be:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
 80001c2:	f8d2 342c 	ldr.w	r3, [r2, #1068]	@ 0x42c
 80001c6:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 80001ca:	f8c2 342c 	str.w	r3, [r2, #1068]	@ 0x42c
        DEVMAP->ADC[ADC1].REGs.SQR3  = ADC_CHANNEL_B1;       // Canal 9 (PB1) como primera conversión
 80001ce:	f8c2 5434 	str.w	r5, [r2, #1076]	@ 0x434
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 80001d2:	6843      	ldr	r3, [r0, #4]
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001d4:	f8d2 1408 	ldr.w	r1, [r2, #1032]	@ 0x408
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 80001d8:	f023 63e0 	bic.w	r3, r3, #117440512	@ 0x7000000
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 80001dc:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001e0:	f041 0102 	orr.w	r1, r1, #2
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 80001e4:	6043      	str	r3, [r0, #4]
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001e6:	f8c2 1408 	str.w	r1, [r2, #1032]	@ 0x408
        
        // Ahora encender y calibrar
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Encender ADC (primera vez)
 80001ea:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 80001ee:	f043 0301 	orr.w	r3, r3, #1
 80001f2:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        for(volatile int i=0; i<1000; i++);                  // Delay para estabilización
 80001f6:	9401      	str	r4, [sp, #4]
 80001f8:	9b01      	ldr	r3, [sp, #4]
 80001fa:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80001fe:	da06      	bge.n	800020e <main+0x12e>
 8000200:	9b01      	ldr	r3, [sp, #4]
 8000202:	3301      	adds	r3, #1
 8000204:	9301      	str	r3, [sp, #4]
 8000206:	9b01      	ldr	r3, [sp, #4]
 8000208:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800020c:	dbf8      	blt.n	8000200 <main+0x120>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 3);             // RSTCAL: Reset calibration
 800020e:	4a44      	ldr	r2, [pc, #272]	@ (8000320 <main+0x240>)
 8000210:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000214:	f043 0308 	orr.w	r3, r3, #8
 8000218:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 3));       // Esperar que se complete reset
 800021c:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000220:	071c      	lsls	r4, r3, #28
 8000222:	d4fb      	bmi.n	800021c <main+0x13c>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 8000224:	f8d2 1408 	ldr.w	r1, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000228:	4b3d      	ldr	r3, [pc, #244]	@ (8000320 <main+0x240>)
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 800022a:	f041 0104 	orr.w	r1, r1, #4
 800022e:	f8c2 1408 	str.w	r1, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000232:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
 8000236:	0750      	lsls	r0, r2, #29
 8000238:	d4fb      	bmi.n	8000232 <main+0x152>
        // ========================================
        // Configurar PA[15:0] como salidas 50MHz push-pull
        // ========================================
	// CRL configura PA[7:0]:   MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
	// CRH configura PA[15:8]:  MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 800023a:	f04f 3433 	mov.w	r4, #858993459	@ 0x33333333
        DEVMAP->ADC[ADC1].REGs.CR2 &= ~(0b111 << 17);        // EXTSEL = 111 (SWSTART)
 800023e:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 8000242:	4836      	ldr	r0, [pc, #216]	@ (800031c <main+0x23c>)
        DEVMAP->ADC[ADC1].REGs.CR2 &= ~(0b111 << 17);        // EXTSEL = 111 (SWSTART)
 8000244:	f422 2260 	bic.w	r2, r2, #917504	@ 0xe0000
 8000248:	f8c3 2408 	str.w	r2, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |=  (0b111 << 17);
 800024c:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
        // ========================================
        // Bucle principal: encender LEDs en secuencia
        // ========================================
        // Preparar estado inicial del comparador de umbral
        // Descartar la primera muestra tras el arranque para evitar lecturas iniciales incorrectas
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000250:	4a33      	ldr	r2, [pc, #204]	@ (8000320 <main+0x240>)
        DEVMAP->ADC[ADC1].REGs.CR2 |=  (0b111 << 17);
 8000252:	f441 2160 	orr.w	r1, r1, #917504	@ 0xe0000
 8000256:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |= (1 << 20);             // EXTTRIG habilitado
 800025a:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 800025e:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000262:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Iniciar conversión continua
 8000266:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 800026a:	f041 0101 	orr.w	r1, r1, #1
 800026e:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |= (1 << 22);             // SWSTART: disparar conversión
 8000272:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 8000276:	f441 0180 	orr.w	r1, r1, #4194304	@ 0x400000
 800027a:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 800027e:	f8c0 4800 	str.w	r4, [r0, #2048]	@ 0x800
        DEVMAP->GPIOs[GPIOA].REGs.CRH = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[15:8] como salidas
 8000282:	f8c0 4804 	str.w	r4, [r0, #2052]	@ 0x804
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000286:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 800028a:	0799      	lsls	r1, r3, #30
 800028c:	d5fb      	bpl.n	8000286 <main+0x1a6>
        (void)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 800028e:	f8d2 344c 	ldr.w	r3, [r2, #1100]	@ 0x44c

        // Preparar estado inicial del comparador de umbral con la siguiente conversión válida
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000292:	4a23      	ldr	r2, [pc, #140]	@ (8000320 <main+0x240>)
 8000294:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 8000298:	079b      	lsls	r3, r3, #30
 800029a:	d5fb      	bpl.n	8000294 <main+0x1b4>
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 800029c:	f240 5a54 	movw	sl, #1364	@ 0x554
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 80002a0:	f8d2 344c 	ldr.w	r3, [r2, #1100]	@ 0x44c


        // Habilitar interrupción de fin de conversión
        DEVMAP->ADC[ADC1].REGs.CR1 |= (1 << 5);             // EOCIE
        ENA_IRQ(IRQ_ADC1_2);
 80002a4:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 80002a8:	b29b      	uxth	r3, r3
 80002aa:	4553      	cmp	r3, sl
 80002ac:	bf8c      	ite	hi
 80002ae:	2300      	movhi	r3, #0
 80002b0:	2301      	movls	r3, #1
        ENA_IRQ(IRQ_ADC1_2);
 80002b2:	f44f 2880 	mov.w	r8, #262144	@ 0x40000


        for(;;) {
            DEVMAP->GPIOs[GPIOA].REGs.ODR = led_pattern[(((DEVMAP->TIMs[TIM2].REGs.CNT - last_capture_ticks) / delta_ticks)+laps) % LED_PATTERN_LENGTH];
 80002b6:	f04f 4780 	mov.w	r7, #1073741824	@ 0x40000000
 80002ba:	26b4      	movs	r6, #180	@ 0xb4
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 80002bc:	f8df 9064 	ldr.w	r9, [pc, #100]	@ 8000324 <main+0x244>
 80002c0:	4d19      	ldr	r5, [pc, #100]	@ (8000328 <main+0x248>)
 80002c2:	f889 3000 	strb.w	r3, [r9]
        DEVMAP->ADC[ADC1].REGs.CR1 |= (1 << 5);             // EOCIE
 80002c6:	f8d2 3404 	ldr.w	r3, [r2, #1028]	@ 0x404
 80002ca:	4c18      	ldr	r4, [pc, #96]	@ (800032c <main+0x24c>)
 80002cc:	f043 0320 	orr.w	r3, r3, #32
 80002d0:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
        ENA_IRQ(IRQ_ADC1_2);
 80002d4:	f8df e058 	ldr.w	lr, [pc, #88]	@ 8000330 <main+0x250>
 80002d8:	f8c1 8100 	str.w	r8, [r1, #256]	@ 0x100
 80002dc:	f8df c054 	ldr.w	ip, [pc, #84]	@ 8000334 <main+0x254>
            DEVMAP->GPIOs[GPIOA].REGs.ODR = led_pattern[(((DEVMAP->TIMs[TIM2].REGs.CNT - last_capture_ticks) / delta_ticks)+laps) % LED_PATTERN_LENGTH];
 80002e0:	4815      	ldr	r0, [pc, #84]	@ (8000338 <main+0x258>)
 80002e2:	490e      	ldr	r1, [pc, #56]	@ (800031c <main+0x23c>)
 80002e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80002e6:	f8d5 8000 	ldr.w	r8, [r5]
 80002ea:	6822      	ldr	r2, [r4, #0]
 80002ec:	eba3 0308 	sub.w	r3, r3, r8
 80002f0:	fbb3 f3f2 	udiv	r3, r3, r2
 80002f4:	f8be 2000 	ldrh.w	r2, [lr]
 80002f8:	b292      	uxth	r2, r2
 80002fa:	4413      	add	r3, r2
 80002fc:	089a      	lsrs	r2, r3, #2
 80002fe:	fba0 8202 	umull	r8, r2, r0, r2
 8000302:	0892      	lsrs	r2, r2, #2
 8000304:	fb06 3312 	mls	r3, r6, r2, r3
 8000308:	f83c 3013 	ldrh.w	r3, [ip, r3, lsl #1]
 800030c:	f8c1 380c 	str.w	r3, [r1, #2060]	@ 0x80c
        for(;;) {
 8000310:	e7e8      	b.n	80002e4 <main+0x204>
 8000312:	bf00      	nop
 8000314:	40021000 	.word	0x40021000
 8000318:	40022000 	.word	0x40022000
 800031c:	40010000 	.word	0x40010000
 8000320:	40012000 	.word	0x40012000
 8000324:	20000024 	.word	0x20000024
 8000328:	20000020 	.word	0x20000020
 800032c:	20000018 	.word	0x20000018
 8000330:	2000001e 	.word	0x2000001e
 8000334:	0800043c 	.word	0x0800043c
 8000338:	16c16c17 	.word	0x16c16c17

0800033c <ADC1_2_IRQHandler>:

        return 0;
}

void ADC1_2_IRQHandler(void)
{
 800033c:	b5f0      	push	{r4, r5, r6, r7, lr}
        // Leer DR (esto automáticamente limpia EOC en modo continuo)
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 800033e:	4b35      	ldr	r3, [pc, #212]	@ (8000414 <ADC1_2_IRQHandler+0xd8>)

    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 8000340:	4a35      	ldr	r2, [pc, #212]	@ (8000418 <ADC1_2_IRQHandler+0xdc>)
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 8000342:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 8000346:	7811      	ldrb	r1, [r2, #0]
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 8000348:	b29b      	uxth	r3, r3
    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 800034a:	b9a1      	cbnz	r1, 8000376 <ADC1_2_IRQHandler+0x3a>
 800034c:	f240 5154 	movw	r1, #1364	@ 0x554
 8000350:	428b      	cmp	r3, r1
 8000352:	d810      	bhi.n	8000376 <ADC1_2_IRQHandler+0x3a>
        low_detected = 1;
 8000354:	2301      	movs	r3, #1
 8000356:	7013      	strb	r3, [r2, #0]
    }

    if (low_detected && (sample > ADC_THRESHOLD_HIGH_RAW)) {
 8000358:	7813      	ldrb	r3, [r2, #0]
            last_capture_ticks = current_ticks;
            low_detected = 0;
            laps = (laps + 1) % 180;
    }
	DEVMAP->ADC[ADC1].REGs.SR &= ~(1 << 1);					// Clear EOC bit
	CLR_IRQ(IRQ_ADC1_2);
 800035a:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
 800035e:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
	DEVMAP->ADC[ADC1].REGs.SR &= ~(1 << 1);					// Clear EOC bit
 8000362:	4a2c      	ldr	r2, [pc, #176]	@ (8000414 <ADC1_2_IRQHandler+0xd8>)
 8000364:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 8000368:	f023 0302 	bic.w	r3, r3, #2
 800036c:	f8c2 3400 	str.w	r3, [r2, #1024]	@ 0x400
	CLR_IRQ(IRQ_ADC1_2);
 8000370:	f8c1 0280 	str.w	r0, [r1, #640]	@ 0x280
}
 8000374:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (low_detected && (sample > ADC_THRESHOLD_HIGH_RAW)) {
 8000376:	7811      	ldrb	r1, [r2, #0]
 8000378:	2900      	cmp	r1, #0
 800037a:	d0ee      	beq.n	800035a <ADC1_2_IRQHandler+0x1e>
 800037c:	f240 714e 	movw	r1, #1870	@ 0x74e
 8000380:	428b      	cmp	r3, r1
 8000382:	d9ea      	bls.n	800035a <ADC1_2_IRQHandler+0x1e>
            uint32_t current_ticks = DEVMAP->TIMs[TIM2].REGs.CNT;
 8000384:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
            if (ticks_one_lap > 100 && ticks_one_lap < 60000) {
 8000388:	f64e 11ab 	movw	r1, #59819	@ 0xe9ab
            uint32_t ticks_one_lap = (current_ticks - last_capture_ticks) & 0xFFFF; // Manejar desbordamiento de 16 bits
 800038c:	4823      	ldr	r0, [pc, #140]	@ (800041c <ADC1_2_IRQHandler+0xe0>)
            uint32_t current_ticks = DEVMAP->TIMs[TIM2].REGs.CNT;
 800038e:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
            uint32_t ticks_one_lap = (current_ticks - last_capture_ticks) & 0xFFFF; // Manejar desbordamiento de 16 bits
 8000390:	6803      	ldr	r3, [r0, #0]
 8000392:	1ae3      	subs	r3, r4, r3
 8000394:	b29b      	uxth	r3, r3
            if (ticks_one_lap > 100 && ticks_one_lap < 60000) {
 8000396:	f1a3 0cb4 	sub.w	ip, r3, #180	@ 0xb4
 800039a:	458c      	cmp	ip, r1
 800039c:	d828      	bhi.n	80003f0 <ADC1_2_IRQHandler+0xb4>
                uint32_t new_delta = ticks_one_lap / LED_PATTERN_LENGTH;
 800039e:	4920      	ldr	r1, [pc, #128]	@ (8000420 <ADC1_2_IRQHandler+0xe4>)
                    delta_sum -= delta_buffer[delta_buffer_index];  // Restar valor viejo
 80003a0:	4d20      	ldr	r5, [pc, #128]	@ (8000424 <ADC1_2_IRQHandler+0xe8>)
                uint32_t new_delta = ticks_one_lap / LED_PATTERN_LENGTH;
 80003a2:	089b      	lsrs	r3, r3, #2
                    delta_sum -= delta_buffer[delta_buffer_index];  // Restar valor viejo
 80003a4:	f895 c000 	ldrb.w	ip, [r5]
                uint32_t new_delta = ticks_one_lap / LED_PATTERN_LENGTH;
 80003a8:	fba1 1303 	umull	r1, r3, r1, r3
                    delta_sum -= delta_buffer[delta_buffer_index];  // Restar valor viejo
 80003ac:	4f1e      	ldr	r7, [pc, #120]	@ (8000428 <ADC1_2_IRQHandler+0xec>)
 80003ae:	4e1f      	ldr	r6, [pc, #124]	@ (800042c <ADC1_2_IRQHandler+0xf0>)
 80003b0:	f857 102c 	ldr.w	r1, [r7, ip, lsl #2]
                uint32_t new_delta = ticks_one_lap / LED_PATTERN_LENGTH;
 80003b4:	ea4f 0e93 	mov.w	lr, r3, lsr #2
                    delta_sum -= delta_buffer[delta_buffer_index];  // Restar valor viejo
 80003b8:	ebc1 0193 	rsb	r1, r1, r3, lsr #2
 80003bc:	6833      	ldr	r3, [r6, #0]
                    delta_buffer[delta_buffer_index] = new_delta;   // Guardar nuevo valor
 80003be:	f847 e02c 	str.w	lr, [r7, ip, lsl #2]
                    delta_sum += new_delta;                         // Sumar nuevo valor
 80003c2:	440b      	add	r3, r1
                    delta_buffer_index = (delta_buffer_index + 1) % MOVING_AVG_SIZE;
 80003c4:	491a      	ldr	r1, [pc, #104]	@ (8000430 <ADC1_2_IRQHandler+0xf4>)
 80003c6:	f10c 0e01 	add.w	lr, ip, #1
                    delta_sum += new_delta;                         // Sumar nuevo valor
 80003ca:	6033      	str	r3, [r6, #0]
                    delta_ticks = delta_sum / MOVING_AVG_SIZE;
 80003cc:	fba1 6303 	umull	r6, r3, r1, r3
                    delta_buffer_index = (delta_buffer_index + 1) % MOVING_AVG_SIZE;
 80003d0:	fba1 610e 	umull	r6, r1, r1, lr
                    delta_ticks = delta_sum / MOVING_AVG_SIZE;
 80003d4:	4e17      	ldr	r6, [pc, #92]	@ (8000434 <ADC1_2_IRQHandler+0xf8>)
                    delta_buffer_index = (delta_buffer_index + 1) % MOVING_AVG_SIZE;
 80003d6:	f021 0c03 	bic.w	ip, r1, #3
                    delta_ticks = delta_sum / MOVING_AVG_SIZE;
 80003da:	089b      	lsrs	r3, r3, #2
                    delta_buffer_index = (delta_buffer_index + 1) % MOVING_AVG_SIZE;
 80003dc:	eb0c 0191 	add.w	r1, ip, r1, lsr #2
                    delta_ticks = delta_sum / MOVING_AVG_SIZE;
 80003e0:	6033      	str	r3, [r6, #0]
                    delta_buffer_index = (delta_buffer_index + 1) % MOVING_AVG_SIZE;
 80003e2:	ebae 0301 	sub.w	r3, lr, r1
 80003e6:	702b      	strb	r3, [r5, #0]
                    if (delta_ticks == 0) {
 80003e8:	6833      	ldr	r3, [r6, #0]
 80003ea:	b90b      	cbnz	r3, 80003f0 <ADC1_2_IRQHandler+0xb4>
                        delta_ticks = 1;
 80003ec:	2301      	movs	r3, #1
 80003ee:	6033      	str	r3, [r6, #0]
            low_detected = 0;
 80003f0:	2300      	movs	r3, #0
            last_capture_ticks = current_ticks;
 80003f2:	6004      	str	r4, [r0, #0]
            laps = (laps + 1) % 180;
 80003f4:	24b4      	movs	r4, #180	@ 0xb4
 80003f6:	4910      	ldr	r1, [pc, #64]	@ (8000438 <ADC1_2_IRQHandler+0xfc>)
            low_detected = 0;
 80003f8:	7013      	strb	r3, [r2, #0]
            laps = (laps + 1) % 180;
 80003fa:	880b      	ldrh	r3, [r1, #0]
 80003fc:	4808      	ldr	r0, [pc, #32]	@ (8000420 <ADC1_2_IRQHandler+0xe4>)
 80003fe:	b29b      	uxth	r3, r3
 8000400:	3301      	adds	r3, #1
 8000402:	089a      	lsrs	r2, r3, #2
 8000404:	fba0 0202 	umull	r0, r2, r0, r2
 8000408:	0892      	lsrs	r2, r2, #2
 800040a:	fb04 3312 	mls	r3, r4, r2, r3
 800040e:	b29b      	uxth	r3, r3
 8000410:	800b      	strh	r3, [r1, #0]
 8000412:	e7a2      	b.n	800035a <ADC1_2_IRQHandler+0x1e>
 8000414:	40012000 	.word	0x40012000
 8000418:	20000024 	.word	0x20000024
 800041c:	20000020 	.word	0x20000020
 8000420:	16c16c17 	.word	0x16c16c17
 8000424:	2000001c 	.word	0x2000001c
 8000428:	20000004 	.word	0x20000004
 800042c:	20000000 	.word	0x20000000
 8000430:	cccccccd 	.word	0xcccccccd
 8000434:	20000018 	.word	0x20000018
 8000438:	2000001e 	.word	0x2000001e

0800043c <led_pattern>:
 800043c:	80808080 80808080 90c09fff 90c090c0     ................
 800044c:	88a090c0 8080879f 9fef8080 80808080     ................
 800045c:	88a0879f 91c090c0 89c091c0 808087a0     ................
 800046c:	9fef8080 80808080 80c080c0 9fff80c0     ................
 800047c:	80c080c0 808080c0 9c808080 829e8381     ................
 800048c:	829e82e0 9c808381 80808080 90809fff     ................
 800049c:	90809080 90809080 80808080 90c29fff     ................
 80004ac:	90c090c2 90c090c0 80808080 90a2889c     ................
 80004bc:	90c190c2 90c190c1 80808fa0 80808080     ................
 80004cc:	90c090c0 90c09fff 808090c0 90c08080     ................
 80004dc:	9fff90c0 90c090c0 80808080 00008080     ................
 80004ec:	00000000 80828082 80858085 81888188     ................
 80004fc:	82908290 84a084a0 98c098c0 84a084a0     ................
 800050c:	82908290 81888188 80858085 80828082     ................
 800051c:	00000000 80808080 9fff8080 809080a0     ................
 800052c:	80908088 9fff80a0 80808080 80809fef     ................
 800053c:	9fff8080 81c180c1 84c282c1 808098bc     ................
 800054c:	9c808080 828e8381 82c082b8 828e82b8     ................
 800055c:	9c808381 80808080 80c19fff 82c181c1     ................
 800056c:	98bc84c2 80808080 88a0879f 90c090c0     ................
 800057c:	90c090c0 80808080 81809fff 81808180     ................
 800058c:	81808180 80809fff 9fef8080 80808080     ................
 800059c:	80808080 80808080                       ........


main.elf:     file format elf32-littlearm
main.elf
architecture: armv7, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080000e1

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x0000053c memsz 0x0000053c flags r-x
    LOAD off    0x00002000 vaddr 0x20000000 paddr 0x0800053c align 2**12
         filesz 0x00000004 memsz 0x00000008 flags rw-
private flags = 0x5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000053c  08000000  08000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  20000000  0800053c  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  20000004  08000540  00002004  2**1
                  ALLOC
  3 .debug_info   00000c41  00000000  00000000  00002004  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000248  00000000  00000000  00002c45  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_loclists 00000036  00000000  00000000  00002e8d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000028  00000000  00000000  00002ec3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_rnglists 0000001b  00000000  00000000  00002eeb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   0000044c  00000000  00000000  00002f06  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    00000492  00000000  00000000  00003352  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000046  00000000  00000000  000037e4  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002d  00000000  00000000  0000382a  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000054  00000000  00000000  00003858  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
08000000 l    d  .text	00000000 .text
20000000 l    d  .data	00000000 .data
20000004 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 main.c
20000006 l     O .bss	00000001 low_detected
20000000 l     O .data	00000004 delta_ticks
20000004 l     O .bss	00000002 laps
080003d4 l     O .text	00000168 led_pattern
0800032c g     F .text	000000a8 ADC1_2_IRQHandler
08000000 g     O .text	000000e0 vector_table
080000e0 g     F .text	0000024c main



Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 50 00 20 e1 00 00 08 00 00 00 00 00 00 00 00     .P. ............
	...
 8000088:	2d 03 00 08 00 00 00 00 00 00 00 00 00 00 00 00     -...............
	...

080000e0 <main>:
	0,														// 0x0000_00DC
};


int main(void)
{
 80000e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// ========================================
	// Configuración de reloj: 72MHz vía PLL
	// ========================================
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 80000e4:	4b88      	ldr	r3, [pc, #544]	@ (8000308 <main+0x228>)
{
 80000e6:	b082      	sub	sp, #8
	DEVMAP->RCC.REGs.CR |= (1 << 16);              // Habilitar HSE (8MHz)
 80000e8:	681a      	ldr	r2, [r3, #0]
 80000ea:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 80000ee:	601a      	str	r2, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 17)));    // Esperar HSE ready
 80000f0:	681a      	ldr	r2, [r3, #0]
 80000f2:	0397      	lsls	r7, r2, #14
 80000f4:	d5fc      	bpl.n	80000f0 <main+0x10>
	
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 80000f6:	6819      	ldr	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 80000f8:	4a83      	ldr	r2, [pc, #524]	@ (8000308 <main+0x228>)
	DEVMAP->RCC.REGs.CR &= ~(1 << 24);             // Deshabilitar PLL
 80000fa:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 80000fe:	6019      	str	r1, [r3, #0]
	DEVMAP->RCC.REGs.CFGR |= (0b0111 << 18);       // PLLMUL = 9 (8MHz * 9 = 72MHz)
 8000100:	6859      	ldr	r1, [r3, #4]
 8000102:	f441 11e0 	orr.w	r1, r1, #1835008	@ 0x1c0000
 8000106:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CFGR |= (1 << 16);            // PLLSRC = HSE
 8000108:	6859      	ldr	r1, [r3, #4]
 800010a:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 800010e:	6059      	str	r1, [r3, #4]
	DEVMAP->RCC.REGs.CR |= (1 << 24);              // Habilitar PLL
 8000110:	6819      	ldr	r1, [r3, #0]
 8000112:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 8000116:	6019      	str	r1, [r3, #0]
	while (!(DEVMAP->RCC.REGs.CR & (1 << 25)));    // Esperar PLL ready
 8000118:	6813      	ldr	r3, [r2, #0]
 800011a:	019e      	lsls	r6, r3, #6
 800011c:	d5fc      	bpl.n	8000118 <main+0x38>
	
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
	
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 800011e:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000122:	4c7a      	ldr	r4, [pc, #488]	@ (800030c <main+0x22c>)
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 8000124:	4b78      	ldr	r3, [pc, #480]	@ (8000308 <main+0x228>)
	DEVMAP->FLASH.REGs.ACR |= (0b010 << 0);        // FLASH: 2 wait states
 8000126:	6820      	ldr	r0, [r4, #0]
 8000128:	f040 0002 	orr.w	r0, r0, #2
 800012c:	6020      	str	r0, [r4, #0]
        DEVMAP->RCC.REGs.CFGR |= (0b100 << 8);         // APB1: /2 (36MHz)
 800012e:	6850      	ldr	r0, [r2, #4]
 8000130:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
 8000134:	6050      	str	r0, [r2, #4]
	DEVMAP->RCC.REGs.CFGR |= (0b10 << 0);          // SW = PLL
 8000136:	6850      	ldr	r0, [r2, #4]
 8000138:	f040 0002 	orr.w	r0, r0, #2
 800013c:	6050      	str	r0, [r2, #4]
	while (!(DEVMAP->RCC.REGs.CFGR & (0b10 << 2))); // Esperar conmutación
 800013e:	685a      	ldr	r2, [r3, #4]
 8000140:	0715      	lsls	r5, r2, #28
 8000142:	d5fc      	bpl.n	800013e <main+0x5e>
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);

        // ========================================
        // Configurar TIM2 como contador libre para time-stamping
        // ========================================
        DEVMAP->TIMs[TIM2].REGs.CR1 = 0;
 8000144:	2400      	movs	r4, #0
        DEVMAP->TIMs[TIM2].REGs.PSC = TIM2_PRESCALER_30KHZ;            // 72MHz / 2400 = 30kHz -> 33.33us por tick
 8000146:	f640 1c5f 	movw	ip, #2399	@ 0x95f
        DEVMAP->TIMs[TIM2].REGs.ARR = TIM2_AUTO_RELOAD_MAX_16BIT;      // Conteo libre de 16 bits
 800014a:	f64f 77ff 	movw	r7, #65535	@ 0xffff
        DEVMAP->RCC.REGs.APB1ENR |= (1 << 0);  // TIM2 clock enable
 800014e:	69da      	ldr	r2, [r3, #28]

        // Configurar ADC primero, ANTES de encender
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (ADC_SAMPLE_TIME_CYCLES << (3 * ADC_CHANNEL_B1)); // Sample time = 239.5 ciclos
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
        DEVMAP->ADC[ADC1].REGs.SQR3  = ADC_CHANNEL_B1;       // Canal 9 (PB1) como primera conversión
 8000150:	2509      	movs	r5, #9
        DEVMAP->RCC.REGs.APB1ENR |= (1 << 0);  // TIM2 clock enable
 8000152:	f042 0201 	orr.w	r2, r2, #1
 8000156:	61da      	str	r2, [r3, #28]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 8000158:	699a      	ldr	r2, [r3, #24]
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 800015a:	486d      	ldr	r0, [pc, #436]	@ (8000310 <main+0x230>)
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 2);  // GPIOA clock enable
 800015c:	f042 0204 	orr.w	r2, r2, #4
 8000160:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 3);  // GPIOB clock enable
 8000162:	699a      	ldr	r2, [r3, #24]
 8000164:	f042 0208 	orr.w	r2, r2, #8
 8000168:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 9);  // ADC1 clock enable
 800016a:	699a      	ldr	r2, [r3, #24]
 800016c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8000170:	619a      	str	r2, [r3, #24]
        DEVMAP->RCC.REGs.APB2ENR |= (1 << 0);  // AFIO clock enable
 8000172:	699a      	ldr	r2, [r3, #24]
 8000174:	f042 0201 	orr.w	r2, r2, #1
 8000178:	619a      	str	r2, [r3, #24]
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 800017a:	f8d0 6c00 	ldr.w	r6, [r0, #3072]	@ 0xc00
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
 800017e:	4a65      	ldr	r2, [pc, #404]	@ (8000314 <main+0x234>)
        DEVMAP->GPIOs[GPIOB].REGs.CRL &= ~((uint32_t)0xF << 4);
 8000180:	f026 06f0 	bic.w	r6, r6, #240	@ 0xf0
 8000184:	f8c0 6c00 	str.w	r6, [r0, #3072]	@ 0xc00
        DEVMAP->TIMs[TIM2].REGs.CR1 = 0;
 8000188:	600c      	str	r4, [r1, #0]
        DEVMAP->TIMs[TIM2].REGs.PSC = TIM2_PRESCALER_30KHZ;            // 72MHz / 2400 = 30kHz -> 33.33us por tick
 800018a:	f8c1 c028 	str.w	ip, [r1, #40]	@ 0x28
        DEVMAP->TIMs[TIM2].REGs.ARR = TIM2_AUTO_RELOAD_MAX_16BIT;      // Conteo libre de 16 bits
 800018e:	62cf      	str	r7, [r1, #44]	@ 0x2c
        DEVMAP->TIMs[TIM2].REGs.CNT = 0;
 8000190:	624c      	str	r4, [r1, #36]	@ 0x24
        DEVMAP->TIMs[TIM2].REGs.CR1 |= (1 << 0);             // CEN: habilitar contador
 8000192:	680e      	ldr	r6, [r1, #0]
 8000194:	f046 0601 	orr.w	r6, r6, #1
 8000198:	600e      	str	r6, [r1, #0]
        DEVMAP->RCC.REGs.CFGR &= ~(0b11 << 14);
 800019a:	6859      	ldr	r1, [r3, #4]
 800019c:	f421 4140 	bic.w	r1, r1, #49152	@ 0xc000
 80001a0:	6059      	str	r1, [r3, #4]
        DEVMAP->RCC.REGs.CFGR |=  (0b11 << 14);             // ADCPRE = 10: PCLK2/6
 80001a2:	6859      	ldr	r1, [r3, #4]
 80001a4:	f441 4140 	orr.w	r1, r1, #49152	@ 0xc000
 80001a8:	6059      	str	r1, [r3, #4]
        DEVMAP->ADC[ADC1].REGs.SMPR2 &= ~(0b111 << (3 * ADC_CHANNEL_B1));
 80001aa:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80001ae:	f023 5360 	bic.w	r3, r3, #939524096	@ 0x38000000
 80001b2:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SMPR2 |=  (ADC_SAMPLE_TIME_CYCLES << (3 * ADC_CHANNEL_B1)); // Sample time = 239.5 ciclos
 80001b6:	f8d2 3410 	ldr.w	r3, [r2, #1040]	@ 0x410
 80001ba:	f043 5360 	orr.w	r3, r3, #939524096	@ 0x38000000
 80001be:	f8c2 3410 	str.w	r3, [r2, #1040]	@ 0x410
        DEVMAP->ADC[ADC1].REGs.SQR1 &= ~(0b1111 << 20);      // Longitud de secuencia = 1
 80001c2:	f8d2 342c 	ldr.w	r3, [r2, #1068]	@ 0x42c
 80001c6:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 80001ca:	f8c2 342c 	str.w	r3, [r2, #1068]	@ 0x42c
        DEVMAP->ADC[ADC1].REGs.SQR3  = ADC_CHANNEL_B1;       // Canal 9 (PB1) como primera conversión
 80001ce:	f8c2 5434 	str.w	r5, [r2, #1076]	@ 0x434
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 80001d2:	6843      	ldr	r3, [r0, #4]
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001d4:	f8d2 1408 	ldr.w	r1, [r2, #1032]	@ 0x408
        *AFIO_MAPR &= ~(0b111 << 24);  // Limpiar bits SWJ_CFG[26:24]
 80001d8:	f023 63e0 	bic.w	r3, r3, #117440512	@ 0x7000000
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 80001dc:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001e0:	f041 0102 	orr.w	r1, r1, #2
        *AFIO_MAPR |=  (0b010 << 24);  // SWJ_CFG = 010 (Deshabilitar JTAG, mantener SWD)
 80001e4:	6043      	str	r3, [r0, #4]
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 1);             // Modo continuo habilitado
 80001e6:	f8c2 1408 	str.w	r1, [r2, #1032]	@ 0x408
        
        // Ahora encender y calibrar
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Encender ADC (primera vez)
 80001ea:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 80001ee:	f043 0301 	orr.w	r3, r3, #1
 80001f2:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        for(volatile int i=0; i<1000; i++);                  // Delay para estabilización
 80001f6:	9401      	str	r4, [sp, #4]
 80001f8:	9b01      	ldr	r3, [sp, #4]
 80001fa:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80001fe:	da06      	bge.n	800020e <main+0x12e>
 8000200:	9b01      	ldr	r3, [sp, #4]
 8000202:	3301      	adds	r3, #1
 8000204:	9301      	str	r3, [sp, #4]
 8000206:	9b01      	ldr	r3, [sp, #4]
 8000208:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800020c:	dbf8      	blt.n	8000200 <main+0x120>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 3);             // RSTCAL: Reset calibration
 800020e:	4a41      	ldr	r2, [pc, #260]	@ (8000314 <main+0x234>)
 8000210:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000214:	f043 0308 	orr.w	r3, r3, #8
 8000218:	f8c2 3408 	str.w	r3, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 3));       // Esperar que se complete reset
 800021c:	f8d2 3408 	ldr.w	r3, [r2, #1032]	@ 0x408
 8000220:	071c      	lsls	r4, r3, #28
 8000222:	d4fb      	bmi.n	800021c <main+0x13c>
        
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 8000224:	f8d2 1408 	ldr.w	r1, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000228:	4b3a      	ldr	r3, [pc, #232]	@ (8000314 <main+0x234>)
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 2);             // CAL: Iniciar calibración
 800022a:	f041 0104 	orr.w	r1, r1, #4
 800022e:	f8c2 1408 	str.w	r1, [r2, #1032]	@ 0x408
        while (DEVMAP->ADC[ADC1].REGs.CR2 & (1 << 2));       // Esperar que se complete calibración
 8000232:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
 8000236:	0750      	lsls	r0, r2, #29
 8000238:	d4fb      	bmi.n	8000232 <main+0x152>
        // ========================================
        // Configurar PA[15:0] como salidas 50MHz push-pull
        // ========================================
	// CRL configura PA[7:0]:   MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
	// CRH configura PA[15:8]:  MODE=11 (50MHz), CNF=00 (Push-pull) = 0x3 por pin
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 800023a:	f04f 3433 	mov.w	r4, #858993459	@ 0x33333333
        DEVMAP->ADC[ADC1].REGs.CR2 &= ~(0b111 << 17);        // EXTSEL = 111 (SWSTART)
 800023e:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 8000242:	4833      	ldr	r0, [pc, #204]	@ (8000310 <main+0x230>)
        DEVMAP->ADC[ADC1].REGs.CR2 &= ~(0b111 << 17);        // EXTSEL = 111 (SWSTART)
 8000244:	f422 2260 	bic.w	r2, r2, #917504	@ 0xe0000
 8000248:	f8c3 2408 	str.w	r2, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |=  (0b111 << 17);
 800024c:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
        // ========================================
        // Bucle principal: encender LEDs en secuencia
        // ========================================
        // Preparar estado inicial del comparador de umbral
        // Descartar la primera muestra tras el arranque para evitar lecturas iniciales incorrectas
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000250:	4a30      	ldr	r2, [pc, #192]	@ (8000314 <main+0x234>)
        DEVMAP->ADC[ADC1].REGs.CR2 |=  (0b111 << 17);
 8000252:	f441 2160 	orr.w	r1, r1, #917504	@ 0xe0000
 8000256:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |= (1 << 20);             // EXTTRIG habilitado
 800025a:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 800025e:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000262:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2  |= (1 << 0);             // ADON: Iniciar conversión continua
 8000266:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 800026a:	f041 0101 	orr.w	r1, r1, #1
 800026e:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->ADC[ADC1].REGs.CR2 |= (1 << 22);             // SWSTART: disparar conversión
 8000272:	f8d3 1408 	ldr.w	r1, [r3, #1032]	@ 0x408
 8000276:	f441 0180 	orr.w	r1, r1, #4194304	@ 0x400000
 800027a:	f8c3 1408 	str.w	r1, [r3, #1032]	@ 0x408
        DEVMAP->GPIOs[GPIOA].REGs.CRL = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[7:0]  como salidas
 800027e:	f8c0 4800 	str.w	r4, [r0, #2048]	@ 0x800
        DEVMAP->GPIOs[GPIOA].REGs.CRH = GPIO_OUTPUT_MODE_PUSH_PULL;  // PA[15:8] como salidas
 8000282:	f8c0 4804 	str.w	r4, [r0, #2052]	@ 0x804
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000286:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 800028a:	0799      	lsls	r1, r3, #30
 800028c:	d5fb      	bpl.n	8000286 <main+0x1a6>
        (void)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 800028e:	f8d2 344c 	ldr.w	r3, [r2, #1100]	@ 0x44c

        // Preparar estado inicial del comparador de umbral con la siguiente conversión válida
        while (!(DEVMAP->ADC[ADC1].REGs.SR & (1 << 1)));
 8000292:	4a20      	ldr	r2, [pc, #128]	@ (8000314 <main+0x234>)
 8000294:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 8000298:	079b      	lsls	r3, r3, #30
 800029a:	d5fb      	bpl.n	8000294 <main+0x1b4>
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 800029c:	f240 5a54 	movw	sl, #1364	@ 0x554
        uint16_t initial_sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 80002a0:	f8d2 344c 	ldr.w	r3, [r2, #1100]	@ 0x44c


        // Habilitar interrupción de fin de conversión
        DEVMAP->ADC[ADC1].REGs.CR1 |= (1 << 5);             // EOCIE
        ENA_IRQ(IRQ_ADC1_2);
 80002a4:	f04f 27e0 	mov.w	r7, #3758153728	@ 0xe000e000
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 80002a8:	b29b      	uxth	r3, r3
 80002aa:	4553      	cmp	r3, sl
 80002ac:	bf8c      	ite	hi
 80002ae:	2300      	movhi	r3, #0
 80002b0:	2301      	movls	r3, #1
        ENA_IRQ(IRQ_ADC1_2);
 80002b2:	f44f 2880 	mov.w	r8, #262144	@ 0x40000


        for(;;) {
            DEVMAP->GPIOs[GPIOA].REGs.ODR = led_pattern[((DEVMAP->TIMs[TIM2].REGs.CNT  / delta_ticks)+(laps)) % LED_PATTERN_LENGTH];
 80002b6:	f04f 4680 	mov.w	r6, #1073741824	@ 0x40000000
 80002ba:	25b4      	movs	r5, #180	@ 0xb4
        low_detected = (initial_sample < ADC_THRESHOLD_LOW_RAW);
 80002bc:	f8df 9058 	ldr.w	r9, [pc, #88]	@ 8000318 <main+0x238>
 80002c0:	4c16      	ldr	r4, [pc, #88]	@ (800031c <main+0x23c>)
 80002c2:	f889 3000 	strb.w	r3, [r9]
        DEVMAP->ADC[ADC1].REGs.CR1 |= (1 << 5);             // EOCIE
 80002c6:	f8d2 3404 	ldr.w	r3, [r2, #1028]	@ 0x404
 80002ca:	f8df e054 	ldr.w	lr, [pc, #84]	@ 8000320 <main+0x240>
 80002ce:	f043 0320 	orr.w	r3, r3, #32
 80002d2:	f8df c050 	ldr.w	ip, [pc, #80]	@ 8000324 <main+0x244>
            DEVMAP->GPIOs[GPIOA].REGs.ODR = led_pattern[((DEVMAP->TIMs[TIM2].REGs.CNT  / delta_ticks)+(laps)) % LED_PATTERN_LENGTH];
 80002d6:	4814      	ldr	r0, [pc, #80]	@ (8000328 <main+0x248>)
 80002d8:	490d      	ldr	r1, [pc, #52]	@ (8000310 <main+0x230>)
        DEVMAP->ADC[ADC1].REGs.CR1 |= (1 << 5);             // EOCIE
 80002da:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
        ENA_IRQ(IRQ_ADC1_2);
 80002de:	f8c7 8100 	str.w	r8, [r7, #256]	@ 0x100
            DEVMAP->GPIOs[GPIOA].REGs.ODR = led_pattern[((DEVMAP->TIMs[TIM2].REGs.CNT  / delta_ticks)+(laps)) % LED_PATTERN_LENGTH];
 80002e2:	6a73      	ldr	r3, [r6, #36]	@ 0x24
 80002e4:	6827      	ldr	r7, [r4, #0]
 80002e6:	f8be 2000 	ldrh.w	r2, [lr]
 80002ea:	fbb3 f3f7 	udiv	r3, r3, r7
 80002ee:	b292      	uxth	r2, r2
 80002f0:	4413      	add	r3, r2
 80002f2:	089a      	lsrs	r2, r3, #2
 80002f4:	fba0 7202 	umull	r7, r2, r0, r2
 80002f8:	0892      	lsrs	r2, r2, #2
 80002fa:	fb05 3312 	mls	r3, r5, r2, r3
 80002fe:	f83c 3013 	ldrh.w	r3, [ip, r3, lsl #1]
 8000302:	f8c1 380c 	str.w	r3, [r1, #2060]	@ 0x80c
        for(;;) {
 8000306:	e7ec      	b.n	80002e2 <main+0x202>
 8000308:	40021000 	.word	0x40021000
 800030c:	40022000 	.word	0x40022000
 8000310:	40010000 	.word	0x40010000
 8000314:	40012000 	.word	0x40012000
 8000318:	20000006 	.word	0x20000006
 800031c:	20000000 	.word	0x20000000
 8000320:	20000004 	.word	0x20000004
 8000324:	080003d4 	.word	0x080003d4
 8000328:	16c16c17 	.word	0x16c16c17

0800032c <ADC1_2_IRQHandler>:

        return 0;
}

void ADC1_2_IRQHandler(void)
{
 800032c:	b410      	push	{r4}
        // Leer DR (esto automáticamente limpia EOC en modo continuo)
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 800032e:	4b24      	ldr	r3, [pc, #144]	@ (80003c0 <ADC1_2_IRQHandler+0x94>)

    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 8000330:	4a24      	ldr	r2, [pc, #144]	@ (80003c4 <ADC1_2_IRQHandler+0x98>)
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 8000332:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 8000336:	7811      	ldrb	r1, [r2, #0]
    uint16_t sample = (uint16_t)(DEVMAP->ADC[ADC1].REGs.DR & 0xFFFF);
 8000338:	b29b      	uxth	r3, r3
    if (!low_detected && (sample < ADC_THRESHOLD_LOW_RAW)) {
 800033a:	b9a9      	cbnz	r1, 8000368 <ADC1_2_IRQHandler+0x3c>
 800033c:	f240 5154 	movw	r1, #1364	@ 0x554
 8000340:	428b      	cmp	r3, r1
 8000342:	d811      	bhi.n	8000368 <ADC1_2_IRQHandler+0x3c>
        low_detected = 1;
 8000344:	2301      	movs	r3, #1
 8000346:	7013      	strb	r3, [r2, #0]
    }

    if (low_detected && (sample > ADC_THRESHOLD_HIGH_RAW)) {
 8000348:	7813      	ldrb	r3, [r2, #0]
            }
            low_detected = 0;
			laps = (laps + 1) % 180;
    }
	DEVMAP->ADC[ADC1].REGs.SR &= ~(1 << 1);					// Clear EOC bit
	CLR_IRQ(IRQ_ADC1_2);
 800034a:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
 800034e:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
	DEVMAP->ADC[ADC1].REGs.SR &= ~(1 << 1);					// Clear EOC bit
 8000352:	4a1b      	ldr	r2, [pc, #108]	@ (80003c0 <ADC1_2_IRQHandler+0x94>)
}
 8000354:	bc10      	pop	{r4}
	DEVMAP->ADC[ADC1].REGs.SR &= ~(1 << 1);					// Clear EOC bit
 8000356:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 800035a:	f023 0302 	bic.w	r3, r3, #2
 800035e:	f8c2 3400 	str.w	r3, [r2, #1024]	@ 0x400
	CLR_IRQ(IRQ_ADC1_2);
 8000362:	f8c1 0280 	str.w	r0, [r1, #640]	@ 0x280
}
 8000366:	4770      	bx	lr
    if (low_detected && (sample > ADC_THRESHOLD_HIGH_RAW)) {
 8000368:	7811      	ldrb	r1, [r2, #0]
 800036a:	2900      	cmp	r1, #0
 800036c:	d0ed      	beq.n	800034a <ADC1_2_IRQHandler+0x1e>
 800036e:	f240 714e 	movw	r1, #1870	@ 0x74e
 8000372:	428b      	cmp	r3, r1
 8000374:	d9e9      	bls.n	800034a <ADC1_2_IRQHandler+0x1e>
            uint32_t ticks_one_lap = DEVMAP->TIMs[TIM2].REGs.CNT;
 8000376:	f04f 4c80 	mov.w	ip, #1073741824	@ 0x40000000
			DEVMAP->TIMs[TIM2].REGs.CNT = 0;
 800037a:	2400      	movs	r4, #0
            uint32_t ticks_one_lap = DEVMAP->TIMs[TIM2].REGs.CNT;
 800037c:	f8dc 3024 	ldr.w	r3, [ip, #36]	@ 0x24
            delta_ticks = ticks_one_lap / LED_PATTERN_LENGTH; // Ventana de 2 grados
 8000380:	4811      	ldr	r0, [pc, #68]	@ (80003c8 <ADC1_2_IRQHandler+0x9c>)
 8000382:	089b      	lsrs	r3, r3, #2
 8000384:	fba0 0303 	umull	r0, r3, r0, r3
 8000388:	4910      	ldr	r1, [pc, #64]	@ (80003cc <ADC1_2_IRQHandler+0xa0>)
 800038a:	089b      	lsrs	r3, r3, #2
			DEVMAP->TIMs[TIM2].REGs.CNT = 0;
 800038c:	f8cc 4024 	str.w	r4, [ip, #36]	@ 0x24
            delta_ticks = ticks_one_lap / LED_PATTERN_LENGTH; // Ventana de 2 grados
 8000390:	600b      	str	r3, [r1, #0]
            if (delta_ticks <= 0) {
 8000392:	680b      	ldr	r3, [r1, #0]
 8000394:	b90b      	cbnz	r3, 800039a <ADC1_2_IRQHandler+0x6e>
                    delta_ticks = 1;
 8000396:	2301      	movs	r3, #1
 8000398:	600b      	str	r3, [r1, #0]
            low_detected = 0;
 800039a:	2300      	movs	r3, #0
			laps = (laps + 1) % 180;
 800039c:	f04f 0cb4 	mov.w	ip, #180	@ 0xb4
 80003a0:	490b      	ldr	r1, [pc, #44]	@ (80003d0 <ADC1_2_IRQHandler+0xa4>)
            low_detected = 0;
 80003a2:	7013      	strb	r3, [r2, #0]
			laps = (laps + 1) % 180;
 80003a4:	880b      	ldrh	r3, [r1, #0]
 80003a6:	4808      	ldr	r0, [pc, #32]	@ (80003c8 <ADC1_2_IRQHandler+0x9c>)
 80003a8:	b29b      	uxth	r3, r3
 80003aa:	3301      	adds	r3, #1
 80003ac:	089a      	lsrs	r2, r3, #2
 80003ae:	fba0 0202 	umull	r0, r2, r0, r2
 80003b2:	0892      	lsrs	r2, r2, #2
 80003b4:	fb0c 3312 	mls	r3, ip, r2, r3
 80003b8:	b29b      	uxth	r3, r3
 80003ba:	800b      	strh	r3, [r1, #0]
 80003bc:	e7c5      	b.n	800034a <ADC1_2_IRQHandler+0x1e>
 80003be:	bf00      	nop
 80003c0:	40012000 	.word	0x40012000
 80003c4:	20000006 	.word	0x20000006
 80003c8:	16c16c17 	.word	0x16c16c17
 80003cc:	20000000 	.word	0x20000000
 80003d0:	20000004 	.word	0x20000004

080003d4 <led_pattern>:
 80003d4:	80808080 80808080 90c09fff 90c090c0     ................
 80003e4:	88a090c0 8080879f 9fef8080 80808080     ................
 80003f4:	88a0879f 91c090c0 89c091c0 808087a0     ................
 8000404:	9fef8080 80808080 80c080c0 9fff80c0     ................
 8000414:	80c080c0 808080c0 9c808080 829e8381     ................
 8000424:	829e82e0 9c808381 80808080 90809fff     ................
 8000434:	90809080 90809080 80808080 90c29fff     ................
 8000444:	90c090c2 90c090c0 80808080 90a2889c     ................
 8000454:	90c190c2 90c190c1 80808fa0 80808080     ................
 8000464:	90c090c0 90c09fff 808090c0 90c08080     ................
 8000474:	9fff90c0 90c090c0 80808080 00008080     ................
 8000484:	00000000 80828082 80858085 81888188     ................
 8000494:	82908290 84a084a0 98c098c0 84a084a0     ................
 80004a4:	82908290 81888188 80858085 80828082     ................
 80004b4:	00000000 80808080 9fff8080 809080a0     ................
 80004c4:	80908088 9fff80a0 80808080 80809fef     ................
 80004d4:	9fff8080 81c180c1 84c282c1 808098bc     ................
 80004e4:	9c808080 828e8381 82c082b8 828e82b8     ................
 80004f4:	9c808381 80808080 80c19fff 82c181c1     ................
 8000504:	98bc84c2 80808080 88a0879f 90c090c0     ................
 8000514:	90c090c0 80808080 81809fff 81808180     ................
 8000524:	81808180 80809fff 9fef8080 80808080     ................
 8000534:	80808080 80808080                       ........
